# REM против EM - Великий спор

Одна из наиболее успешных практик в веб-типографике - это использование относительных единиц, таких как `rem` и `em`.

Вопрос вот в чем: **какую единицу использовать**? Это давняя дискуссия между сторонниками `rem` и сторонниками `em`, считающими, что вы должны использовать одну единицу, вместо другой.

В этой статье вы познакомитесь с моим взглядом на *`rem` против `em`*. Так же вы разберетесь, что именно из себя представляют эти единицы и как их использовать для создания модульных компонентов.

## Что такое EM?

> EM это единица в типографике, равная текущему указанному `point-size` <cite> Википедия </cite>

Заметка: в печатной типографии размер шрифта измеряется в пунктах, отсюда `point-size`.

Это определение не дает четкого понимания термина в веб среде, потому что мы не используем `point-size`. Однако это приобретает достаточный смысл если заменить `point-size` на `font-size`.

**Соответственно имеем: `1em = 20px` если у текущего селектора `font-size` равен `20px`**.

```scss
h1 { font-size: 20px } /* 1em = 20px */
p { font-size: 16px } /* 1em = 16px */
```

Единица `em` может быть использована для объявления размера шрифта и это явлеяется [хорошей практикой]('ссссылка').

Примите во внимание следующее:

```scss
h1 { font-size: 2em } /* Что именно это означает?! */
```

Какой здесь фактический размер заголовка?

Чтобы это вычислить, мы должны найти родителя этого элемента, у которого задано свойство `font-size`. Допустим это `<html>`, и его `font-size` равен `16px`.

Теперь мы можем сказать, что вычисленный размер шрифта `<h1>` это `32px`, так как `2 * 16px = 32px`.

```scss
html { font-size: 16px }
h1 { font-size: 2em } /* 16px * 2 = 32px */
```

**Хоть это и допустимо, но все же это плохая идея, устанавливать `font-size` у `html` в пикселях**, потому что это переназначает пользовательские настройки браузера.

Вместо этого вы можете вы можете использовать проценты или вообще пропустить объявление `font-size` (тогда `font-size` будет установлено на `100%` по умолчанию).

Для большинства пользователей (и браузеров), `font-size` равный `100%` по умолчанию будет эквивалентен `16px`, если они не меняли это значение в настройках браузера. Редко кто это делает.

С этим понятно. Вернемся к `em`.

Единица **`em` также может быть использована для определения значений и других свойств** помимо `font-size`. Например `margin` и `padding` - два таких свойства, которые часто задаются в `em`.

На этом этапе многие сбиваются при определении значений в `em`.

Рассмотрим следующий код. Какое значение должно быть для `margin-bottom` у элементов `<h1>` и `<p>`? (Предположим `font-size` у `<html>` задан `100%`).

```scss
h1 {
  font-size: 2em; /* 1em = 16px */
  margin-bottom: 1em; /* 1em = 32px */
}

p {
  font-size: 1em; /* 1em = 16px */
  margin-bottom: 1em; /* 1em = 16px */
}
```

Вы удивлены тем, что вычисленное значение `1em` у свойства `margin-bottom` имеет различные значения в этих двух случаях?

Так происходит, потому что `1em` эквивалентен текущему `font-size`.
**Поскольку `font-size` у `<h1>` установлен равным `2em`, то другие свойства `<h1>`, исчисляемые в `em` будут вычисляться с учетом `1em = 32px`**.

`1em` может принимать различные значения в зависимости от контекста применения. Этот факт может сбить с толку тех, кто только начинает пользоваться относительными единицами.

Так или иначе, мы рассмотрели то, что касается `em`. Давайте теперь разберемся с `rem`.

## Что такое REM?

**`rem` означает "корневой `em`" (Root EM)**. Эта единица существует, чтобы облегчить некоторые вычислительные задачи связанные с проблемами, возникающими при использовании `em`.

Типографическая единица `rem` равна размеру шрифта корневого элемента. Фактически это означает, что `1rem` всегда равен `font-size` определенному для `<html>`.

Рассмотрим вышеупомянутый код, переписанный с использованием `rem`. Чему будут равны вычисленные значения `margin-bottom`?

```scss
h1 {
  font-size: 2rem;
  margin-bottom: 1rem; /* 1rem = 16px */
}

p {
  font-size: 1rem;
  margin-bottom: 1rem; /* 1rem = 16px */
}
```

Как вы можете наблюдать, **`1rem` будет всегда принимать одно и то же значение в `16px` вне зависимости от контекста использования** (так будет до тех пор пока вы не замените `font-size` в `<html>`). Это неизменное правило легко запомнить.

Это все что касается `rem`. Несложно для понимания, если вы уловили как работает `em`, неправда ли?

А теперь давайте перейдем к сути этой статьи. `rem` или `em`?

## REM или EM?

**Это достаточно спорный момент**

Некторые разработчики совершенно избегают использования `rem`, утверждая, что использование этой единицы делает их компоненты менее модульными (сужает контекст их применения). Другие же наоборот используют `rem` повсеместно, предпочитая простоту использования, которую дает `rem`.

Как ни странно, в моей карьере разработчика я становился как приверженцем одной практики, так и другой. Мне нравилось как `em` помогал мне создавать модульные компоненты, но результирующий код, который иногда доводилось писать, начинал вызывать у меня отвращение. В то же самое время мне нравилось как `rem` упрощает всю арифметику, но я терпеть не мог все эти хаки, которые приходилось использовать для улучшения масштабируемости компонентов.

Оказывается **`rem` и `em` имеют свои сильные и слабые стороны. Их следует использовать по-разному, в зависимости от обстоятельств.**

Как? **Вот два простых правила:**

1. Используйте `em`, если свойство изменяется в зависимости от текущего размера шрифта.
2. Испольуйте `rem` для всего остального.

Слишком просто? Чтож, давайте напишем простой компонент (заголовочный элемент), используя и `rem` и `em`, и увидим эти правила в деле.

## Использование только REM для создания заголовка

Скажем у нас есть заголовочный элемент (`<h2>`), который выглядит примерно так:

Стили этого заголовочного элемента будут примерно следующими, если вы используете `rem` для определения всех размеров:

```scss
.header {
  font-size: 1rem;
  padding: 0.5rem 0.75rem;
  background: #7F7CFF;
}
```

Пока все вполне нормально.

Теперь давайте создадим заголовочный элемент с чуть большими размерами, ведь иногда на одном и том же сайте нужно использовать несколько вариантов. Реализуя это, будем стараться максимально наследовать существующий код.

Разметка будет выглядеть следующим образом:

```html
<a href="#" class="header header--large">header!</a>
```

CSS будет:

```scss
.header {
  font-size: 1rem;
  padding: 0.5rem 0.75rem;
  background: #7F7CFF;
}

.header--large {
  font-size: 2rem;
}
```

К сожалению код оказался не совершенным. Посмотрите, как мало расстояния между краями элемента `.header--large` и текстом.

Если вы настаиваете на использовании только `rem` единиц, то единственный вариант решения этой проблемы это переписать свойство `padding` для большого заголовка.

```scss
.header {
  font-size: 1rem;
  padding: 0.5rem 0.75rem;
  background: #7F7CFF;
}

.header--large {
  font-size: 2rem;
  padding: 1rem 1.5rem;
}
```

Заметили вы здесь закономерность? **Размер шрифта `.header--large` в два раза больше чем у `.header`. Вследствие этого отступы (`padding`) у `.header--large` же в два раза больше чем `padding` у `.header`.**

Что мы будем делать, если нам нужно будет завести несколько вариантов заголовка с разными размерами шрифта или необходимо будет просто изменить размер шрифта текущего заголовка? Вы уже можете себе представить как повсеместное использование `rem` может привести к куче повторяющегося, сложного кода.

Мы можем заметно упростить подход в этом случае при использовании `em`. Тогда нам не понадобится переобъявлять свойство `padding` для `.header--large`.

```scss
.header {
  font-size: 1rem;
  padding: 0.5em 0.75em;
  background: #7F7CFF;
}

.header--large {
  font-size: 2rem;
}
```

Как вы можете видеть, **`em` может быть невероятно полезен при объявлении размеров для свойств, которые зависят от текущего размера шрифта**. Вот откуда взялось первое правило, упомянутое выше.

Далее давайте посмотрим, что у нас получится, если мы будем использовать только `em` при создании того же заголовка.

## Использование только EM для создания заголовка

Реализация с `em` не сильно отличается от кода с `rem`, который мы написали. Все, что нам нужно сделать, это поменять `rem` на `em`.

```scss
.header {
  font-size: 1em;
  padding: 0.5em 0.75em;
  background: #7F7CFF;
}

.header--large {
  font-size: 2em;
}
```

На данном этапе оба элемента `.header` и `.header--large` будут смотреться идентично вне зависимости от используемых единиц. Но так ли это будет, когда мы попытаемся использовать наши заголовки в полевых условиях? Вовсе нет!

Возьмем оба вариантов заголовка и добавим к ним парочку абзацев текста. В итоге хотелось бы увидеть нечто следующее:

Наша разметка:

```html
<div class="header header--large">A Header Element</div>
<p>A paragraph of text</p>
<p>A paragraph of text</p>
<div class="header">A Header Element</div>
<p>A paragraph of text</p>
```

В стилях необходимо добавить отступы для параграфов:

```scss
p {
  margin-left: 0.75em;
  margin-right: 0.75em;
}
```

Нееет! :(

`padding` слева и справа от `.header--large` слишком велик!

Если вы настаиваете на использовании только `em`, то вот один вариант решения этой проблемы: переобъявление свойств `padding-left` и `padding-right` для большого заголовка:

```scss
.header {
  font-size: 1em;
  padding: 0.5em 0.75em;
  /* Остальные стили */
}

.header--large {
  font-size: 2em;
  padding-left: 0.375em;
  padding-right: 0.375em;
  margin: 0.75em 0;
}
```

Заметили закономерность? **`font-size` элемента `.header--large` в два раза больше `font-size` элемента `.header`. Да, `padding-left` и `padding-right` элемента `.header--large` в два раза меньше `padding-left` и `padding-right` элемента `.header`!**

Так же как и в предыдущем случае вы можете значительно упростить ваш код, если вы не против использование как `rem` так и `em`. Конкретно нужно использовать `rem` для отступов слева и справа, а `em` для отступов сверху и снизу:

```scss
.header {
  padding: 0.5em 0.75rem;
  font-size: 1em;
  background: #7F7CFF;
}

.header--large {
  font-size: 2em;
}
```

Как вы уже заметили, очень удобно использовать `em`, когда вы хотите, чтобы определенное свойство менялось в зависимости от `font-size`. Однако возникают проблемы, когда вы пытаетесь определить размеры относительно `font-size` корневого элемента.

Мы наглядно рассмотрели как `rem` и `em` могут быть совместно использованы в создании компонента. Теперь давайте пойдем дальше и посмотрим, как заголовок и параграф будут взаимодействовать с модульной сеткой.

## Расположение элементов в модульной сетке

Прежде мы начнем, давайте объединим наш заголовок и параграф в единый компонент:

```html
<div class="component">
  <div class="component__header">A header element</div>
  <p>Some paragraph text</p>
</div>
```

И зададим вот такие базовые стили:

```scss
.component {
  background: white;
  border: 2px solid #7F7CFF;
}

.component__header {
  font-size: 2em;
  padding: 0.5em 1.5rem;
  background: #7F7CFF;
  margin: 0;
}

.component p {
  padding-left: 1.5rem;
  padding-right: 1.5rem;
  margin: 1.5rem 0;
}
```

Неплохо. Это все, к чему мы пришли в предыдущих разделах.

Двигаемся дальше. Этот компонент может находиться на странице в различных ее частях. Предполагаемые областями будут такие:

1. Зона основного контента.
2. Боковая панель.
3. И все это в макете с соотношением 1/3
4. ...
