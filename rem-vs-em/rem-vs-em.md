# REM против EM - Великий спор

Одна из наиболее успешных практик в веб-типографике - это использование относительных единиц, таких как `rem` и `em`.

Вопрос вот в чем: **какую единицу использовать**? Это давняя дискуссия между сторонниками `rem` и сторонниками `em`, считающими, что вы должны использовать одну единицу, вместо другой.

В этой статье вы познакомитесь с моим взглядом на *`rem` против `em`*. Так же вы разберетесь, что именно из себя представляют эти единицы и как их использовать для создания модульных компонентов.

## Что такое EM?

> EM это единица в типографике, равная текущему указанному `point-size` <cite> Википедия </cite>

Заметка: в печатной типографии размер шрифта измеряется в пунктах, отсюда `point-size`.

Это определение не дает четкого понимания термина в веб среде, потому что мы не используем `point-size`. Однако это приобретает достаточный смысл если заменить `point-size` на `font-size`.

**Соответственно имеем: `1em = 20px` если у текущего селектора `font-size` равен `20px`**.

```scss
h1 { font-size: 20px } /* 1em = 20px */
p { font-size: 16px } /* 1em = 16px */
```

Единица `em` может быть использована для объявления размера шрифта и это явлеяется [хорошей практикой]('ссссылка').

Примите во внимание следующее:

```scss
h1 { font-size: 2em } /* Что именно это означает?! */
```

Какой здесь фактический размер заголовка?

Чтобы это вычислить, мы должны найти родителя этого элемента, у которого задано свойство `font-size`. Допустим это `<html>`, и его `font-size` равен `16px`.

Теперь мы можем сказать, что вычисленный размер шрифта `<h1>` это `32px`, так как `2 * 16px = 32px`.

```scss
html { font-size: 16px }
h1 { font-size: 2em } /* 16px * 2 = 32px */
```

**Хоть это и допустимо, но все же это плохая идея, устанавливать `font-size` у `html` в пикселях**, потому что это переназначает пользовательские настройки браузера.

Вместо этого вы можете вы можете использовать проценты или вообще пропустить объявление `font-size` (тогда `font-size` будет установлено на `100%` по умолчанию).

Для большинства пользователей (и браузеров), `font-size` равный `100%` по умолчанию будет эквивалентен `16px`, если они не меняли это значение в настройках браузера. Редко кто это делает.

С этим понятно. Вернемся к `em`.

Единица **`em` также может быть использована для определения значений и других свойств** помимо `font-size`. Например `margin` и `padding` - два таких свойства, которые часто задаются в `em`.

На этом этапе многие сбиваются при определении значений в `em`.

Рассмотрим следующий код. Какое значение должно быть для `margin-bottom` у элементов `<h1>` и `<p>`? (Предположим `font-size` у `<html>` задан `100%`).

```scss
h1 {
  font-size: 2em; /* 1em = 16px */
  margin-bottom: 1em; /* 1em = 32px */
}

p {
  font-size: 1em; /* 1em = 16px */
  margin-bottom: 1em; /* 1em = 16px */
}
```

Вы удивлены тем, что вычисленное значение `1em` у свойства `margin-bottom` имеет различные значения в этих двух случаях?

Так происходит, потому что `1em` эквивалентен текущему `font-size`.
**Поскольку `font-size` у `<h1>` установлен равным `2em`, то другие свойства `<h1>`, исчисляемые в `em` будут вычисляться с учетом `1em = 32px`**.

`1em` может принимать различные значения в зависимости от контекста применения. Этот факт может сбить с толку тех, кто только начинает пользоваться относительными единицами.

Так или иначе, мы рассмотрели то, что касается `em`. Давайте теперь разберемся с `rem`.

## Что такое REM?

**`rem` означает "корневой `em`" (Root EM)**. Эта единица существует, чтобы облегчить некоторые вычислительные задачи связанные с проблемами, возникающими при использовании `em`.

Типографическая единица `rem` равна размеру шрифта корневого элемента. Фактически это означает, что `1rem` всегда равен `font-size` определенному для `<html>`.

Рассмотрим вышеупомянутый код, переписанный с использованием `rem`. Чему будут равны вычисленные значения `margin-bottom`?

```scss
h1 {
  font-size: 2rem;
  margin-bottom: 1rem; /* 1rem = 16px */
}

p {
  font-size: 1rem;
  margin-bottom: 1rem; /* 1rem = 16px */
}
```

Как вы можете наблюдать, **`1rem` будет всегда принимать одно и то же значение в `16px` вне зависимости от контекста использования** (так будет до тех пор пока вы не замените `font-size` в `<html>`). Это неизменное правило легко запомнить.

Это все что касается `rem`. Несложно для понимания, если вы уловили как работает `em`, неправда ли?

А теперь давайте перейдем к сути этой статьи. `rem` или `em`?

## REM или EM?

**Это достаточно спорный момент**

Некторые разработчики совершенно избегают использования `rem`, утверждая, что использование этой единицы делает их компоненты менее модульными (сужает контекст их применения). Другие же наоборот используют `rem` повсеместно, предпочитая простоту использования, которую дает `rem`.

Как ни странно, в моей карьере разработчика я становился как приверженцем одной практики, так и другой. Мне нравилось как `em` помогал мне создавать модульные компоненты, но результирующий код, который иногда доводилось писать, начинал вызывать у меня отвращение. В то же самое время мне нравилось как `rem` упрощает всю арифметику, но я терпеть не мог все эти хаки, которые приходилось использовать для улучшения масштабируемости компонентов.

Оказывается **`rem` и `em` имеют свои сильные и слабые стороны. Их следует использовать по-разному, в зависимости от обстоятельств.**

Как? **Вот два простых правила:**

1. Используйте `em`, если свойство изменяется в зависимости от текущего размера шрифта.
2. Испольуйте `rem` для всего остального.

Слишком просто? Чтож, давайте напишем простой компонент (заголовочный элемент), используя и `rem` и `em`, и увидим эти правила в деле.

## Использование только REM для создания заголовка

Скажем у нас есть заголовочный элемент (`<h2>`), который выглядит примерно так:

Стили этого заголовочного элемента будут примерно следующими, если вы используете `rem` для определения всех размеров:

```scss
.header {
  font-size: 1rem;
  padding: 0.5rem 0.75rem;
  background: #7F7CFF;
}
```

Пока все вполне нормально.

Теперь давайте создадим заголовочный элемент с чуть большими размерами, ведь иногда на одном и том же сайте нужно использовать несколько вариантов. Реализуя это, будем стараться максимально наследовать существующий код.

Разметка будет выглядеть следующим образом:

```html
<a href="#" class="header header--large">header!</a>
```

CSS будет:

```scss
.header {
  font-size: 1rem;
  padding: 0.5rem 0.75rem;
  background: #7F7CFF;
}

.header--large {
  font-size: 2rem;
}
```

К сожалению код оказался не совершенным. Посмотрите, как мало расстояния между краями элемента `.header--large` и текстом.

Если вы настаиваете на использовании только `rem` единиц, то единственный вариант решения этой проблемы это переписать свойство `padding` для большого заголовка.

```scss
.header {
  font-size: 1rem;
  padding: 0.5rem 0.75rem;
  background: #7F7CFF;
}

.header--large {
  font-size: 2rem;
  padding: 1rem 1.5rem;
}
```

Заметили вы здесь закономерность? **Размер шрифта `.header--large` в два раза больше чем у `.header`. Вследствие этого отступы (`padding`) у `.header--large` же в два раза больше чем `padding` у `.header`.**

Что мы будем делать, если нам нужно будет завести несколько вариантов заголовка с разными размерами шрифта или необходимо будет просто изменить размер шрифта текущего заголовка? Вы уже можете себе представить как повсеместное использование `rem` может привести к куче повторяющегося, сложного кода.

Мы можем заметно упростить подход в этом случае при использовании `em`. Тогда нам не понадобится переобъявлять свойство `padding` для `.header--large`.

```scss
.header {
  font-size: 1rem;
  padding: 0.5em 0.75em;
  background: #7F7CFF;
}

.header--large {
  font-size: 2rem;
}
```

Как вы можете видеть, **`em` может быть невероятно полезен при объявлении размеров для свойств, которые зависят от текущего размера шрифта**. Вот откуда взялось первое правило, упомянутое выше.

Далее давайте посмотрим, что у нас получится, если мы будем использовать только `em` при создании того же заголовка.

## Использование только EM для создания заголовка

Реализация с `em` не сильно отличается от кода с `rem`, который мы написали. Все, что нам нужно сделать, это поменять `rem` на `em`.

```scss
.header {
  font-size: 1em;
  padding: 0.5em 0.75em;
  background: #7F7CFF;
}

.header--large {
  font-size: 2em;
}
```

На данном этапе оба элемента `.header` и `.header--large` будут смотреться идентично вне зависимости от используемых единиц. Но так ли это будет, когда мы попытаемся использовать наши заголовки в полевых условиях? Вовсе нет!

Возьмем оба вариантов заголовка и добавим к ним парочку абзацев текста. В итоге хотелось бы увидеть нечто следующее:

Наша разметка:

```html
<div class="header header--large">A Header Element</div>
<p>A paragraph of text</p>
<p>A paragraph of text</p>
<div class="header">A Header Element</div>
<p>A paragraph of text</p>
```

В стилях необходимо добавить отступы для параграфов:

```scss
p {
  margin-left: 0.75em;
  margin-right: 0.75em;
}
```

Нееет! :(

`padding` слева и справа от `.header--large` слишком велик!

Если вы настаиваете на использовании только `em`, то вот один вариант решения этой проблемы: переобъявление свойств `padding-left` и `padding-right` для большого заголовка:

```scss
.header {
  font-size: 1em;
  padding: 0.5em 0.75em;
  /* Остальные стили */
}

.header--large {
  font-size: 2em;
  padding-left: 0.375em;
  padding-right: 0.375em;
  margin: 0.75em 0;
}
```

Заметили закономерность? **`font-size` элемента `.header--large` в два раза больше `font-size` элемента `.header`. Да, `padding-left` и `padding-right` элемента `.header--large` в два раза меньше `padding-left` и `padding-right` элемента `.header`!**

Так же как и в предыдущем случае вы можете значительно упростить ваш код, если вы не против использование как `rem` так и `em`. Конкретно нужно использовать `rem` для отступов слева и справа, а `em` для отступов сверху и снизу:

```scss
.header {
  padding: 0.5em 0.75rem;
  font-size: 1em;
  background: #7F7CFF;
}

.header--large {
  font-size: 2em;
}
```

Как вы уже заметили, очень удобно использовать `em`, когда вы хотите, чтобы определенное свойство менялось в зависимости от `font-size`. Однако возникают проблемы, когда вы пытаетесь определить размеры относительно `font-size` корневого элемента.

Мы наглядно рассмотрели как `rem` и `em` могут быть совместно использованы в создании компонента. Теперь давайте пойдем дальше и посмотрим, как заголовок и параграф будут взаимодействовать с модульной сеткой.

## Расположение элементов в модульной сетке

Прежде мы начнем, давайте объединим наш заголовок и параграф в единый компонент:

```html
<div class="component">
  <div class="component__header">A header element</div>
  <p>Some paragraph text</p>
</div>
```

И зададим вот такие базовые стили:

```scss
.component {
  background: white;
  border: 2px solid #7F7CFF;
}

.component__header {
  font-size: 2em;
  padding: 0.5em 1.5rem;
  background: #7F7CFF;
  margin: 0;
}

.component p {
  padding-left: 1.5rem;
  padding-right: 1.5rem;
  margin: 1.5rem 0;
}
```

Неплохо. Это все, к чему мы пришли в предыдущих разделах.

Двигаемся дальше. Этот компонент может находиться на странице в различных ее частях. Допустим нам нужно:

1. Зона основного контента.
2. Боковая панель.
3. И все это в макете с соотношением 1/3
4. ...

Заголовочный элемент должен приобрести меньший `font-size`, когда окажется в узкой обертке, такой как боковая панель.

Мы можем сделать это добавив соответствующий класс к нашему компоненту. Разметака получится примерно такая:

```html
<div class="component component--small">
  <!-- Содержимое компонента -->
</div>
```

И стиль для этого вида компонента:

```scss
.component--small .component__header {
  font-size: 1em;
}
```

Теперь немного о стилях. Снова соблюдаются два тех самых правила:

1. Используйте `em`, если свойство изменяется в зависимости от текущего размера шрифта.
2. Испольуйте `rem` для всего остального.

Так же как и с этим заголовочным элементом, вы можете определить какие свойства измерять в `em`, оценив их поведение и взаимодействие с остальными элементами на странице. Вот два варианта, каким образом мы можем построить подобный компонент:

1. Свойства **всех** внутренних элементов изменять в соответствии c `font-size`.
2. Свойства **некоторых** внутренних элементов изменять в соответствии с `font-size`.

Давайте построим такой компонент и вы увидидте, что я имею в виду.

## Вариант 1: Свойства *всех* внутренних элементов изменяются в соответствии c размером шрифта компонента

Давайте начнем с примера, демонстрирующего вид такого компонента:

Обратили внимание как `font-size`, `margin` и `padding` всех элементов в пределах компонента изменяются в одно и то же время?

Если компонент ведет себя подобным образом при изменении ширины экрана, то это значит, что все размеры прописаны в `em`, а код выглядит так:

```scss
.component {
  background: white;
  border: 2px solid #7F7CFF;
}

.component__header {
  font-size: 2em;
  padding: 0.5em 0.75em; /* padding перевли em */
  background: #7F7CFF;
  margin: 0;
}

.component p {
  padding-left: 1.5em; /* padding перевели в em */
  padding-right: 1.5em; /* padding перевели в em */
  margin: 1.5em 0; /* margin перевели в em */
}

// Small variant
.component--small .component__header {
  font-size: 1em;
  padding-left: 1.5em; /* добавили padding в em */
  padding-right: 1.5em; /* добавили padding в em */
}
```

Теперь, чтобы инициировать смену размеров, необходимо лишь изменить размер шрифта компонента:

```scss
.component {
  // Остальные стили
  @media (min-width: 800px) {
    font-size: 1.5em;
  }
}
```

Пока все хорошо. Настало время немного усложнить задачу.

Предствим, что мы имеем модульную сетку как на картинке. Вертикальные и горизонтальные свободные пространства между каждым компонентом сетки должны оставаться одинаковыми на всех устройствах (из эстетических соображений).

Разметка для этой сетки такова:

```html
<div class="grid">
  <div class="grid-item">
    <div class="component"> <!-- компонент --> </div>
  </div>

  <div class="grid-item">
    <div class="component component--small"> <!-- A --> </div>
    <div class="component component--small"> <!-- B --> </div>
  </div>
</div>
```

Я установил ширину просвета между каждым компонентом сетки равной `2em` от корневого `font-size` в `16px`. Другими словами, вычесленная ширина просвета равна `32px`.

Сложность в этой ситуации заключается в том, чтобы разделить компоненты A и B отступом в `32px`. Мы можем попробовать установить `margin-top` компоненту B в `2em` для начала.

```scss
.component {
  /* Остальные стили */
  @media (min-width: 800px) {
    font-size: 1.25em;
  }
}

.component + .component {
  margin-top: 2em;
}
```

К сожалению это не работает в общем случае. Этот отступ больше чем обозначенная ширина просвета (`32px`) при ширине окна браузера больше 800px.

Так происходит,  потому что `font-size` компонента равняется `1.5em` (или `24px`), кода ширина окна браузера больше чем `800px`. Так как `font-size` установлен на `24px`, то вычисленным значением `2em` является `48px`, что не совпадает с `32px`, которые нам нужны.

Бррррр!  (╯°□°）╯︵ ┻━┻

К счастью мы легко можем решить эту проблему используя `rem`, поскольку мы знаем, что ширина просвета изменяется в соответствии с `font-size` корневого элемента.

```scss
.component + .component {
  margin-top: 2rem;
}
```

Та-дааа! Проблема решена :) Вот codepen, чтобы поиграться с этим.

<p data-height="344" data-theme-id="0" data-slug-hash="JGVXOo" data-default-tab="result" data-user="zellwk" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/zellwk/pen/JGVXOo/">REM vs EM – Case 1</a> by Zell Liew (<a href="http://codepen.io/zellwk">@zellwk</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

Заметка: Вам понадобится технология флексбокса, чтобы построить эту сетку. Я не буду объяснять как это работает, так как это выходит за рамки темы. Посмотрите [вот эту статью](https://www.smashingmagazine.com/2015/12/website-layout-tools-compared-flexbox-vs-susy/ "Flexbox vs Susy"), если вам интересно узнать немного больше о флексбоксе.

Да, кстати, не я придумал эту технику. Chris Coyier [написал об этом](https://css-tricks.com/rems-ems/ "Font Size Idea: px at the Root, rem for Components, em for Text Elements") 2 года назад. (Он гений).

## Вариант 2: Свойства *некоторых* внутренних элементов изменяются в соответствии c размером шрифта компонента

Первый пример был довольно прост для понимания. Хотя есть в нем и отрицательные стороны: достаточно тяжело придерживаться модульному масштабированию, вертикальному ритму и быть уверенным, что все компоненты выглядят хорошо одновременно (особенно, когда создается отзывчивый сайт).

Иногда требуется немного поднастроить небольшую часть вашего компонента, а не менять размеры всего одновременно. К примеру, нам может понадобиться менять только размеры заголовка при переходе к большему экрану.

Приступим к реализации, используя уже готовые стили из предыдущих примеров:

```scss
.component {
  background: white;
  border: 2px solid #7F7CFF;
}

.component__header {
  font-size: 2em;
  padding: 0.5em 1.5rem;
  background: #7F7CFF;
  margin: 0;
}

.component p {
  padding-left: 1.5rem;
  padding-right: 1.5rem;
  margin: 1.5rem 0;
}

.component--small .component__header {
  font-size: 1em;
}
```

Допустим мы хотим изменить `font-size` заголовка при ширине экрана в `1200px`. Мы можем без последствий сделать это, прописывая все свойства в `rem` за исключением `padding-top` и `padding-bottom` заголовка.

```scss
.component {
  background: white;
  border: 2px solid #7F7CFF;
}

.component__header {
  font-size: 2rem;
  padding: 0.5em 1.5rem;
  background: #7F7CFF;
}

.component p {
  padding-left: 1.5rem;
  padding-right: 1.5rem;
  margin: 1.5rem 0;
}

.component--small .component__header {
  font-size: 1rem;
}
```

Теперь можем изменить размер шрифта заголовка при переходе к широкому экрану:

```scss
.component__header {
  font-size: 2rem;
  @media (min-width: 1200px) {
    font-size: 3rem
  }
}

.component--small .component__header {
  font-size: 1rem;
  @media (min-width: 1200px) {
    font-size: 1.5rem
  }
}
```

Та-дааа! Заметили, что только заголовок меняется в размерах? Вот мы можем оформлять стили согласно Примеру 2.

Еще один момент.

Лучше всего не связывать свойство `font-size` с конкретным компонентом. Таким образом мы можем гарантировать, что типографика будет согласована между всеми компонентами.

```scss
h2 {
  font-size: 2rem;
  @media (min-width: 1200px) {
    font-size: 3rem
  }
}

h3 {
  font-size: 1rem;
  @media (min-width: 1200px) {
    font-size: 1.5rem
  }
}

.component__header { @extend h2; }
.component--small .component__header { @extend h3; }
```

Вот все что касается Примера 2. Здесь редактируемый пример:

<p data-height="265" data-theme-id="0" data-slug-hash="rxbJMQ" data-default-tab="result" data-user="zellwk" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/zellwk/pen/rxbJMQ/">REM vs EM – Case 2</a> by Zell Liew (<a href="http://codepen.io/zellwk">@zellwk</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

Возможно у вас возник вопрос: "Какого метода лучше всего придерживаться?"
Я бы сказал, что это зависит от вашего дизайна.

Что касается меня, то я чаще всего работаю со вторым примером чем с первым, поскольку я предпочитаю выносить типографические стили в отдельный файл.

## Подытоживая

Итак, должны ли вы использовать `rem` или `em`? Я думаю, что это неправильный вопрос. Каждая из этих единиц имеет свою плюсы и минусы, и они могут быть использованы вместе, лишь бы помочь вам создавать простые масштабируемые компоненты!
