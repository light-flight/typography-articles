# Все, что я знаю об отзывчивой веб-типографике

Отзывчивая типографика - крепкий орешек. Это все, что я мог придумать, когда я впервые занялся созданием отзывчивых сайтов:

```scss
p {
  font-size: 16px;
}

@media (min-width: 800px) {
  p {
    font-size: 18px;
  }
}

/* Повторить для h1 - h6 и остальных типографических элементов */
```

С тех пор я научился гораздо большему в типографике и подобрал лучшие практики такие, как использование относительных единиц, вертикального ритма и контекстного масштабирования элементов.

Эти новые методы оказались просто замечательными. Благодаря им, мои веб-сайты стали приятней для глаз. Однако их применение было ужасным испытанием.

Мне приходилось писать сложный код и вскоре я обнаружил, что написание отзывчивых сайтов превратилось в борьбу под тяжелым давлением времени.

Теперь, спустя месяцы зубрежки, я наконец-то нашел решение, которым счастлив поделиться с вами. Я назвал его Typi.

Typi дает возможность использовать изученные мной методы и в то же самое время решает множество проблем, с которыми я столкнулся, в 3 простых шага. Позвольте мне рассказать про эти три пункта с помощью практик, которые я использую когда работаю с отзывчивой типографикой.

## Практика 1: Увеличение font-size и line-height c увеличением ширины экрана.

Чтение с мобильных устройств и настольного компьютера это две абсолютно разные вещи. Вы определенно держите ближе свой девайс ближе, когда читаете со смартфона, поскольку экран меньше.

Экран компьютера или ноутбука будет заметно дальше от вас в сравнении с экраном смартфона. Следовательно один и тот же font-size на компьютере смотрится немного мельче в связи с большим расстоянием от экрана.

Чтобы увеличить читабельность и потери в размере в связи с увеличенным расстояния, мы увеличиваем размер шрифта.

Впервые я узнал об этой практике в посте об [основах отзывчивой типографики](https://ia.net/know-how/responsive-typography-the-basics "RESPONSIVE TYPOGRAPHY: THE BASICS") на [ia.net](https://ia.net/ "iA is a strategic design agency"). Я бы очень рекомендовал этот пост, если вы не знакомы с этой концепцией.

Эту практику можно применить, используя Sass, следующим образом:

```scss
html {
  font-size: 16px;

  @media (min-width: 800px) {
    font-size: 18px;
  }

  @media (min-width: 1200px) {
    font-size: 20px;
  }
}
```

Заметка: как только мы увеличиваем размер шрифта, мы так же должны увеличить и высоту строки, чтобы создать больше пространства между строками в тексте. С Sass мы можем сделать это может выглядеть так:

```scss
html {
  font-size: 16px;
  line-height: 1.3;

  @media (min-width: 800px) {
    font-size: 18px;
  }

  @media (min-width: 1200px) {
    font-size: 20px;
    line-height: 1.4;
  }
}
```

## Практика 2: Использование модульного масштабирования.

Подбор размера шрифта для элементов форматирования текста (таких как `h1` ... `h2`) дело непростое, особенно если вы пытаетесь придумать их из воздуха. Модульное масштабирование это подход, который поможет вам выбрать правильные размеры шрифта, которые будут хорошо смотреться и сочетаться на странице.

Используя этот подход вы получаете последовательность чисел, каждое из которых больше предыдущего в определенном соотношении. Этого можно добиться умножением исходного размера шрифта элемента `html` на определенный коэффициент (соотношение). Полученное число мы снова умножаем на этот коэффициент и так далее.

Применение, указанного на картинке, модульного масштабирования может быть таким:

```scss
html { font-size: 16px }
h1 { font-size: 50px }
h2 { font-size: 37px }
h3 { font-size: 28px }
// ...
```

Разумеется на деле это не так просто. Если вы возьмете в расчет предыдущую практику, которую уже обсудили в этой статье, вы заметите что размер шрифта должен меняться в зависимости от ширины экрана.

Уже на этом этапе возникнет проблема, если вы попытаетесь изменить размеры шрифта всех ваших элементов на каждой опорной точке (на каждом breakpoint'е). Потому что сохранение текущего масштабирования превратится в кропотливый и неблагодарный труд.

```scss
html {
  font-size: 16px;
  line-height: 1.3;
  @media (min-width: 800px) {
    font-size: 18px;
  }

  @media (min-width: 1200px) {
    font-size: 20px;
    line-height: 1.4;
  }
}

h1 {
  font-size: 50px;
  @media (min-width: 800px) {
    font-size: 56px;
  }
  @media (min-width: 1200px) {
    font-size: 63px;
  }
}

h2 {
  font-size: 37px;
  @media (min-width: 800px) {
    font-size: 42px;
  }
  @media (min-width: 1200px) {
    font-size: 47px;
  }
}

h2 {
  font-size: 28px;
  @media (min-width: 800px) {
    font-size: 32px;
  }
  @media (min-width: 1200px) {
    font-size: 35px;
  }
}
// ...
```

Ухх...

В поисках решения проблемы перемещаемся к следующей практике.

Заметка: если вам необходима помощь с подбором вашего начального значения `font-size` и коэффициента для модульного масштабирования, рекомендую к прочтению эту статью [meaningful typography](http://alistapart.com/article/more-meaningful-typography "More Meaningful Typography") Тима Брауна.

## Практика 3: Использование относительных единиц.

Относительные единицы в CSS это проценты (`%`), единицы окна просмотра (вьюпорта) `vh`, `vw`, `vmin`, `vmax` и единицы (`em`) и (`rem` ). Для определения размеров типографических элементов обычно использут **em** и **rem**.

Вы можете использовать как **em** так и **rem** схожим образом для решения проблем, с которыми мы столкнулись во второй практике. Чтыбы перевести пиксели в em, нужно взять нужный нам `font-size` и поделить его на базовый размер шрифта.

Вот как это выглядит:

```scss
html {
  font-size: 16px;
  @media (min-width: 800px) {
    font-size: 18px;
  }
  @media (min-width: 1200px) {
    font-size: 20px;
  }
}

h1 { font-size: 3.125em; } // 50 ÷ 16 = 3.125
h2 { font-size: 2.3125em;} // 37 ÷ 16 = 2.3125
h3 { font-size: 1.75em; } // 28 ÷ 16 = 1.75
// ...

// Заметка: Здесь мы видим приблизительные значения.
// Актуальные значения, полученные с сайта modularscale.com это 3.129em, 2.3353em и 1.769em соответственно.
```

Теперь намного лучше!

<p data-height="265" data-theme-id="0" data-slug-hash="OMmEqg" data-default-tab="html,result" data-user="zellwk" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/zellwk/pen/OMmEqg/">Responsive Typography – Relative Units </a> by Zell Liew (<a href="http://codepen.io/zellwk">@zellwk</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

Но есть некоторые проблемы. Обратите внимание как заголовок верхнего уровная `<h1>` приобретает размеры приблизительно в 63px, когда ширина экрана превосходит `1200px`.

`63px` это многовато. Заголовок `<h1>` начинает становиться нечитабельным. Лучше бы установить ему размер в `47px` (размер `<h2>`).

Когда мы это сделаем, нам скорее всего захочется уменьшить размеры заголовка второго уровня, чтобы подчеркнуть значимость элемента `<h1>`. Соответственно, необходимо также поправить значение `line-height`.

Код приобретает следующий вид:

```scss
html {
  font-size: 16px;
  @media (min-width: 800px) {
    font-size: 18px;
  }
  @media (min-width: 1200px) {
    font-size: 20px;
  }
}

h1 {
  font-size: 3.129em;
  line-height: 1.2;

  @media (min-width: 1200px) {
    font-size: 2.3353em;
    line-height: 1.3;
  }
}

h2 {
  font-size: 2.3353em;
  @media (min-width: 1200px) {
    font-size: 1.769em;
  }
}

h3 {
  font-size: 1.769em;
  @media (min-width: 1200px) {
    font-size: 1.33em;
  }
}

// ...
```

Мда. И снова тоже самое :(

Вот, где в дело вступает [Typi](https://github.com/zellwk/typi "Typi"). Давайте ненадолго оторвемся от наших практик и посмотрем чем нам сможет помочь Typi.

## Использование Typi

Typi это Sass библиотека которая позволяет настроить свойства `font-size` и `line-height` всех ваших типографических элементов в специальных Sass мапах (ассоциативных массивах). Эти мапы впоследствии выводят код, который мы видели прежде. Вот как это работает.

Во-первых, необходимо настроить `$typi` мапу. Это выглядит примерно так:

```scss
$typi: (
  null: 16px,
  small: 18px,
  large: 20px
);
```

`null`, `small` и `large` это наши опорные точки (breakpoints).

Typi автоматически смотрит мапу `$breakpoints`, чтобы создать медиа-запросы (это означает, что библиотека отлично совмещается с [mappy-breakpoints](https://github.com/zellwk/mappy-breakpoints "Mappy Breakpoints, A Breakpoint Mixin that uses Sass Maps") - библиотекой, которую я создал для упрощения работы с медиа-запросами).

```scss
$breakpoints: (
  small: 800px,
  large: 1200px
);
```

Когда `$typi` мапа уже настроена, мы вызываем `typi-base()` миксин в `html` селекторе.

```scss
html {
  @include typi-base();
}
```

Этот `typi-base()` миксин создает стили, которые мы написали для `html` в Практике 2. Единственное отличие в том, что размеры шрифта устанавливаются в процентах.

```scss
html {
  font-size: 100%; /* Эквивалентно 16px */
}

@media all and (min-width: 800px) {
  html {
    font-size: 112.5%; /* Эквивалентно 18px */
  }
}

@media all and (min-width: 1200px) {
  html {
    font-size: 125%; /* Эквивалентно 20px */
  }
}
```

Мы так же указывали на необходимость поправки `line-height` при изменении `font-size`. Мы можем легко это сделать, добавив второе значение с `line-height` к каждой опорной точке, которая в этом нуждается:

```scss
$typi: (
  null: (16px, 1.3), // Устанавливаем для line-height значение 1.3
  small: 18px,
  large: (20px, 1.4) // Устанавливаем для line-height значение 1.4
);
```

Результирующий CSS благодаря обновленной  `$typi` мапе будет выглядеть так:

```scss
html {
  font-size: 100%; /* This means 16px */
  line-height: 1.3;
}

@media all and (min-width: 800px) {
  html {
    font-size: 112.5%; /* This means 18px */
  }
}

@media all and (min-width: 1200px) {
  html {
    font-size: 125%; /* This means 20px */
    line-height: 1.4;
  }
}
```

После создание онашей основной `$typi` мапы, мы можем создать еще несколько, используя тот же самый формат. Например:

```scss
$h1-map: (
  null: (3.129em, 1.2),
  large: (2.3353em, 1.3)
  );

$h2-map: (
  null: 2.3353em,
  large: 1.769em
  );

$h3-map: (
  null: 1.769em,
  large: 1.333em
  );
// ...
```

И наконец мы вызываем эти мапы используя `typi` миксин:

```scss
h1 { @include typi($h1-map) }
h2 { @include typi($h2-map) }
h3 { @include typi($h3-map) }
// ...
```

Результирующий CSS будет:

```scss
h1 {
  font-size: 3.129em;
  line-height: 1.2;
}

@media (min-width: 1200px) {
  h1 {
    font-size: 2.3353em;
    line-height: 1.3;
  }
}

h2 {
  font-size: 2.3353em;
}

@media (min-width: 1200px) {
  h2 {
    font-size: 1.769em;
  }
}

h3 {
  font-size: 1.769em;
}

@media (min-width: 1200px) {
  h3 {
    font-size: 1.333em;
  }
}
```

Неплохо, правда? Вам нужно будет [загрузить Typi](https://github.com/zellwk/typi "A sass mixin to make responsive typography easy"), чтобы поиграться с этой библиотекой. (Она пока недоступна на Sassmeiser или Codepen).

**СОВЕТ**: Вы также можете использовать Sass миксин модульного масштабирования, если вы не хотите возиться с точными значениями в em (такими как `1.769em`), указывая их в разных мапах.

Чтобы использовать этот миксин, нужно [загрузить библиотеку](https://github.com/modularscale/modularscale-sass "Modular scale calculator built into your Sass") и импортировать ее в ващ Sass файл. После вы можете менять ваши мапы с настройками шрифта, используя функцию `ms()`.

```scss
$h1-map: (
  null: (ms(4) 1.2),
  large: (ms(3), 1.3)
  );

$h2-map: (
  null: ms(3),
  large: ms(2)
  );

$h3-map: (
  null: ms(2),
  large: ms(1)
  );
// ...
```

Итак, в общем вы видим, как [Typi](https://github.com/zellwk/typi "A sass mixin to make responsive typography easy") упрощает работу с отзывчивой типографикой, **прописывая за вас свойства `font-size` и `line-height` для разных опорных точек**.

Теперь, когда мы познакомились с Typi, самое время продолжить разговор о наших заключительных двух практиках (и некоторых проблемах, решение которых я еще не нашел).

## Практика 4: Применение вертикального ритма

Вертикальный ритм это концепция, которую переняли из печатного дизайна (я думаю), и ее принцип гласит, что свободные пространства между элементами должны согласоваться и быть пропорциональными друг другу. Идея, применения этой техники, похожа на идею применения типографического масштабирования - создать гармоничное размещение и соотношение элементов на странице.

На практике мы чаще всего используем свойство `line-height` нашего `body`, как базу для последовательного, повторяющегося вертикального ритма. Скажем, к примеру, `body` нашего сайта имеет **`line-height` в 25px**. Теперь нужно сделать две вещи:

1. Установить **высоту свободного вертикального пространства между элементами кратной 25px**.
2. Установить **line-height всех текстовых элементов кратным 25px**

Вот как это примерно будет смотреться в CSS. (Примечание: здесь еще не используются концепции предыдущих трех практик.)

```scss
html {
  font-size: 18px;
  line-height: 25px;
}

// Resets margins
body, h1, p {
  margin: 0;
}

h1 {
  font-size: 63px;
  line-height: 75px;
  margin: 25px 0;
}

p + p {
  margin-top: 25px;
}
```

<p data-height="265" data-theme-id="0" data-slug-hash="WrjOoa" data-default-tab="result" data-user="zellwk" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/zellwk/pen/WrjOoa/">Vertical Rhythms in PX</a> by Zell Liew (<a href="http://codepen.io/zellwk">@zellwk</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

Смотрится замечательно! Давайте двинемся дальше и используем относительные единицы для выше упомянутого кода. Когда мы попытаемся это сделать, мы столкнемся с большой дискуссией насчет того, какую единицу использовать: `em` или `rem`.

## Em vs Rem

Давайте попробуем перевести наши единицы сначала в **em**, а затем в **rem**. Кстати, наилучшим способом задать значения для высоты строки является [использование безразмерныях единиц](https://css-tricks.com/almanac/properties/l/line-height/ "line-height").

```scss
html {
  font-size: 1.125em;
  line-height: 1.4; // Если быть точным 25.2px
}

// Сбрасываем отступы
body, h1, p {
  margin: 0;
}

h1 {
  // Размер шрифта 63.147px, если быть точным
  font-size: 3.5082em; // 63.147 ÷ 18 = 3.5082em
  line-height: 1.1972; // 75.6 ÷ 63.147 =  1.1972
  margin: 0.3991em 0; // 25.2 ÷ 63.147 = 0.3991
}

p + p {
  margin-top: 1.4em;
}
```

Следует уделить особое внимание тому, как мы конвертировали отступы (`margin`) для `h1` элемента в `em`.

Обратили внимание, как мы использовали `63.147px` как основу для деления. Мы должны делать вычисления таким образом, потому что **размеры в em вычисляются относительно текущего размера шрифта**. Это нередко является причиной замешательства и большого количества сложных вычислений.

Теперь вот в чем загвоздка! Несмотря на то, что мы старались быть точными, насколько это охможно, браузеры не выдают предполагаемый результат. Смотрите как поплыл вертикальный ритм.

<p data-height="265" data-theme-id="0" data-slug-hash="jWmKKZ" data-default-tab="result" data-user="zellwk" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/zellwk/pen/jWmKKZ/">Vertical Rhythms with EM</a> by Zell Liew (<a href="http://codepen.io/zellwk">@zellwk</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

Такому поведению способствуют две причины.

В первую очередь мы не на 100% точны в наших вычислениях. Мы можем проставить до 10 знаков после запятой, но это сделает наш код ужасным как никогда...

Во-вторых, разные браузеры по-разному решают проблемы субпиксельного округления. Это означает, что мы никогда не сможем установить идеальный пиксель-в-пиксель вертикальный ритм, как бы сильно мы не старались.

Чтож, я не намерен больше твердить про субпиксельное округление, потому что мы ничего не можем с этим поделть. Давайте посмотрим на то, как `rem` справится с этой арифметикой.

```scss
html {
  font-size: 1.125rem;
  line-height: 1.4; // Если быть точным 25.2px
}

// Сбрасываем отступы
body, h1, p {
  margin: 0;
}

h1 {
  font-size: 3.5082rem; // 63.147 ÷ 18 = 3.5082
  line-height: 1.1972; // 75.6 ÷ 63.147 = 1.1972
  margin: 1.4rem 0; // 25.2 ÷ 18 = 1.4
}

p + p {
  margin-top: 1.4rem;
}
```

Обратили внимание, как мы использовали `1.4rem` для свойства `margin` вместо `0.3991em`? Единицы **em делают вычисления** вертикального ритма **намного проще**.

**Это не озночает, что мы должны слепо уповать на `rem` единицы**. Rem и em обе полезны, и они должны быть использованы для различных целей. Я напишу об этом статью немного позже, а сейчас давайте вернемся к вертикальному ритму.

Теперь, когда мы конвертировали наш вертикальный ритм в относительные единицы измерения, давайте посмотрим, как это окупится, когда мы совместим это с первой практикой (`font-size` и `line-height` должны увеличиваться, с увеличением ширины экрана).

Постараемся упроситить этот пример, насколько это возможно, и будем использовать всего лишь один медиа-запрос. Также мы используем единицы `rem`.

```scss
html {
  font-size: 1.125em;
  line-height: 1.4;

  @media (min-width: 1200px) {
    font-size: 1.25em; // эквивалентно 20px
    // Небольшое изменение в высоте строки на опорной точке в 1200px
    line-height: 1.45 // эквивалентно 29px
  }
}

// Сбрасываем отступы
body, h1, p {
  margin: 0;
}

h1 {
  font-size: 3.5082em;
  line-height: 1.1972;
  margin: 1.45rem 0;

  @media (min-width: 1200px) {
    // размер шрифта сейчас 70.164px
    line-height: 1.24; // 29px * 3 ÷ 70.164 = 1.24
    margin: 1.45rem 0;
  }
}

p + p {
  margin-top: 1.4em;
  @media (min-width: 1200px) {
    margin-top: 1.45em
  }
}
```

Ухх. Похоже нам придется написать еще `20,000` медиа-запросов, чтобы изменить `margin` и `line-height` всех наших эелемнтов, и все это только потому, что мы изменили свойство `line-height` у `html`. И это мы еще не говорили о свойствах `padding` и `border`!

(╯°□°）╯︵ ┻━┻

Чтож, вот, что я заметил. **Невозможно создать идеальный адаптивный вертикальный ритм для всего многообразия браузеров.** По крайней мере, не с текущей технологией.

Что мы можем сделать вместо этого:

1. Мы можем обойтись лишь основными типографическими элементами, задав им свойство `line-height` на глаз и с использованием Typi.
2. Постараться вообще обойтись без изменений свойства `line-height' корневого элемента. Все станет намного проще, когда большинство браузеров начнут поддерживать [CSS переменные](http://caniuse.com/#search=css%20variables "Поддержка CSS переменных браузерами").

## Практика 5: Установить ширины текстовых блоков в 45-75 символов

О, это просто. Просто запомните: один символ занимает приблизительно 0.5em. Придерживаться размеров в 45-75 символов, значит установить ширину где-то между 22.5em и 37.5em.

Из личного опыта: я больше обеспокоен переполнением символов в строке больше 75. Если это значение падает ниже 45 символов, то скорее всего нужно просто уменьшить размер шрифта.

```scss
article {
  max-width: 30em;
  /* Все что между 22.5em и 37.5em. Настраивайте на ваше усмотрение */
}
```

## Заключение

Адаптивная типографика это сложно. Здесь нет идеальных решений, на которые мы можем положиться, но давайте попробуем обойтись тем, что у нас уже получилось.

Кстати, вот еще одна ссылка на [Typi](https://github.com/zellwk/typi "A sass mixin to make responsive typography easy"), если вы захотите поиграться с этой библиотекой.
