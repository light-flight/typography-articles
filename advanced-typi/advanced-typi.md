# Продвинутое использование Typi

Недавно я написал руководство по использованию функций и миксинов в Typi, библиотеке, созданной мной для работы с отзывчивой типографской. В Typi есть больше возможностей, чем смогло уместиться в предыдущей статье, поэтому в этот раз я хочу поделиться с вами несколькими более продвинутыми методами работы с этой библиотекой.

Вы узнаете:

* Как работать с Typi, если вы хотите использовать медиа-запросы в `em` единицах.
* Как интегрировать Typi с библиотекой модульного масштабирования.
* Как комбинировать модульное масштабирование и вертикальный ритм.

Прежде чем мы начнем, убедитесь, что вы имеете представление о том, [как работают](ссссылка) основные миксины и функции, которые предоставляет Typi.

Давайте начнем.

## Медиа-запросы в `em` с Typi

В [предыдущей статье](ссссылка) я показал как просто можно создать множество медиа-запросов, используя мапы `$breakpoints` и `$typi`. Это уже неплохо, но есть одна проблема. Медиа-запросы, созданные Typi, написаны в пикселях, а профессионалы не одобряют такой подход :(

Вместо пикселей следует использовать относительные единицы `em`. Я углубился в этот вопрос и обнаружил, что `em` медиа-запросы имеют лучшую поддержку большинством браузеров. Вы можете посмотреть мои тесты в [этой статье](ссссылка).

Двигаемся дальше. Существует два способа заставить Typi создавать медиа-запросы в `em`. Первый, это непосредственно задавать значения в `em` в мапе `breakpoints`.

```scss
$breakpoints: (
  small: 25em, // 400px
  large: 50em // 800px
);
```

CSS, который получаем на выходе (обратите внимание на медиа-запросы):

```scss
html {
  font-size: 100%;
  line-height: 1.4;
}
@media all and (min-width: 25em) {
  html { font-size: 112.5%; }
}

@media all and (min-width: 50em) {
  html {font-size: 125%; }
}
```

Теперь мы получили `em`, так произошло потому что Typi работает с любым значением, которое вы задаете в `$brakpoints` мапе.

Несмотря на то, что этот метод работает, он не является лаконичным. Вычислять значения в `em` это большая головная боль для разработчиков, которые хотят максимально упростить свой рабочий процесс.

Существует альтернативный метод (наиболее удобный подход), чтобы создавать медиа-запросы в относительных единицах. Метод заключается в конвертации пикселей в `em` с помощью одной из двух специальных Sass библиотек: [Mappy Breakpoint](https://github.com/zellwk/mappy-breakpoints) и [Breakpoint](http://breakpoint-sass.com).

Typi готова к интеграции с этими библиотеками сразу после их импорта. Вот инструкции по установке:

### Mappy Breakpoints
* **bower:** `bower install mappy-breakpoints --save`
* **npm**: `npm install mappy-breakpoints --save`

### Breakpoint
* **bower:** `bower install breakpoint-sass --save`
* **npm:** `npm install breakpoint-sass --save`

После установки библиотеки, убедитесь, что вы импортировали sass файл до импорта Typi:

```scss
// Выберите одну из них. Убедитесь, что что эта строка находится выше строки с импортом Typi
@import 'path-to-mappy-breakpoints/mappy-breakpoints';
@import 'path-to-breakpoints/stylesheets/breakpoint';

// Импорт Typi
@import 'path-to-typi/scss/typi';

```

Теперь мы уже готовы использовать одну из библиотек. Первым делом нужно дать знать Typi, с чем ей работать. Для этого нужно объявить переменную `$typi-breakpoint` и задать ей в качестве значения название библиотеки:

```scss
// Если вы используете mappy-breakpoints
$typi-breakpoint: mappy-breakpoints;

// Если вы используете breakpoint
$typi-breakpoint: breakpoint;
```

После этого уже можно компилировать ваши Sass файлы. Вы увидите, что пиксельные значения из мапы `$breakpoints` будут конвертированы в `em` автоматически.

```scss
html {
  font-size: 100%;
  line-height: 1.4;
}
@media all and (min-width: 25em) {
  html { font-size: 112.5%; }
}

@media all and (min-width: 50em) {
  html {font-size: 125%; }
}
```

Неплохо, правда?

Я настоятельно рекомендую использовать этот альтернативный метод (с использованием библиотек), потому что с ними у вас появляется преимущество в создании более сложных медиа-запросов. Давайте рассмотрим пару примеров.

Скажем, вам надо написать медиа-запрос, включающий в себя `min-width` и `max-width`. Как Mappy-breakponts, так и Breakpoint представляют вам возможность создать такой запрос, фактически написав лишь два значения ширины, вот так:

```scss
// Mappy Breakpoint
@include mappy-bp(400px 800px) {
	//...
}

// Breakpoint
@include breakpoint(400px 800px) {
	//...
}
```

Мы можем использовать этот синтаксис прямо в мапе `$breakpoints`:

```scss
$breakpoints: (
  small: 400px 800px
);
```

Затем любая из этих библиотек превратит этот маленький "запрос" в обычный, содержащий `(min-width: 400px)` и `(max-width: 800px)`.

Единственное отличие в итоговом css будет в том, что Mappy-breakponts вычтет один пиксель из запроса с максимальной шириной (`max-width: 799px`) во избежание пересечения стилей на значении в `800px`.

```scss
/* Вывод Mappy Breakpoints */
@media all and (min-width: 25em) and (max-width: 49.9375em) {
  html {font-size: 112.5%; }
}

/* Вывод Breakpoint */
@media (min-width: 25em) and (max-width: 50em) {
  html {font-size: 112.5%; }
}
```

Синтаксис в этих двух библиотеках разнится, поэтому если вы намерены создавать более сложные запросы, то стоит посмотреть официальную документацию.

Как насчет еще одного примера?

Допустим вы хотите создать медиа-запрос с `min-width` и `min-height` одновременно. Это довольно распространенная ситуация при работе с отзывчивой типографикой.

В Mappy-breakponts это делается с помощью ключевого слова `height`, после которого следует соответствующее значение min-height:

```scss
$breakpoints: (
  small: 400px height 400px
);
```

В Breakpoint нужно будет прописать соответствующий медиа-запрос в круглых скобках:

```scss
$breakpoints: (
  small: 400px (min-height 400px)
);
```

В оборотах случаях вы получите одинаковый код на выходе:

```scss
@media all and (min-width: 25em) and (min-width: 25em) {
  html {font-size: 112.5%; }
}
```

Далее я предлагаю вам самостоятельно поэкспериментировать с этими библиотеками. Если у вас возникнут вопросы, вы всегда можете вернуться к официальной документации ([Mappy-breakponts](https://github.com/zellwk/mappy-breakpoints) и [Breakpoint](https://github.com/at-import/breakpoint/wiki).)

Двигаемся дальше!

## Работа с модульным масштабированием в Typi

Одной из лучших практик является использование модульного масштабирования для определения `font-size` текстовых элементов.

Когда люди имеют дело с модульным масштабированием, то обычно они используют [специальный калькулятор](http://modularscale.com) или высчитывают размеры шрифтов вручную, умножая базовый размер на определенный коэффициент снова и снова.

Вне зависимости от того какой метод вы выберете, вы будете вводить вычисленные значения вручную:

```scss
h1 { font-size: 3.157em; }
h2 { font-size: 2.369em; }
```

Если вы решите изменить размер базового шрифта, используя медиа-запросы, то это будет выглядеть так:

```scss
h1 { font-size: 3.157em; }
h2 { font-size: 2.369em; }

@media all and (min-width: 25em) {
  h1 { font-size: 4.209em; }
  h2 { font-size: 3.157em; }
}
```

В Typi мы можем получить данный CSS используя специальные мапы (да, они без проблем работают с относительными единицами):

```scss
$h1-map: (
  null: 3.157em,
  small: 4.209em
);

$h2-map: (
  null: 2.369em,
  small: 3.157em
);

h1 { @include typi($h1-map); }
h2 { @include typi($h2-map); }
```

Но этот подход тоже не решает проблему с количеством арифметики, возникающую при желании изменить коэффициент модульного масштабирования. Т.е. если вы меняете соотношение (коэффициент), то вам придется снова вычислить и записать значение размера шрифта каждого элемента один за другим. Бууу :(

К счастью у нас есть более лаконичное решение этой задачи. [Scott Kellum](http://scottkellum.com) и [Tim Brown](http://nicewebtype.com) значительно упростили нам жизнь, создав Sass библиотеку [Modular Scale](https://github.com/modularscale/modularscale-sass).

Вы можете установить библиотеку, используя один из пакетных менеджеров (`bower` или `npm`) или загрузить ее вручную:

* **bower:** `bower install modular-scale --save`
* **npm:** `npm install modular-scale --save`

Затем импортируйте сам Sass файл до или после Typi:

```scss
@import 'path-to-modular-scale/stylesheets/modular-scale';
```

После установки вы можете использовать функцию `ms()` для вычисления размеров шрифтов.

К примеру, вы можете написать `ms(3)`, это будет эквивалентно `2.369em`. Это экономит вам кучу усилий, избавляя от бесконечной арифметики и копипастинга.

```scss
$ms1: ms(1); // => 1em * 1.333 = 1.333em
$ms2: ms(2); // => 1em * 1.333 * 1.333 = 1.777em
$ms3: ms(3); // => 1em * 1.333 * 1.333 * 1.333 = 2.369em
```

По умолчанию в библиотеке используется коэффициент `1.333`. Если вы хотите поменять его, просто объявите переменную `$ms-ratio`:

```scss
$ms-ratio: 1.25;

$ms1: ms(1); // => 1em * 1.25 = 1.25em
$ms2: ms(2); // => 1em * 1.25 * 1.25 = 1.563em
$ms3: ms(3); // => 1em * 1.25 * 1.25 * 1.25 = 1.953em
```

Так как Typi может работать с размерами шрифта в `em`, то она так же на лету интегрируется с функцией `ms()`. Вы можете писать мапы для шрифтов таким образом:

```scss
$h1: (
  null: ms(4),
  small: ms(5)
);
```

С этим арсеналом, вам больше не надо беспокоиться о модульном масштабировании, а точнее не нужно подбирать идеальное соотношение (коэффициент) до того как вы пропишите это в коде. Все будет вычисляться автоматически прямо в Sass. Так что вперед, поиграйтесь с этими инструментами! Попробуйте разные коэффициенты масштабирования и определите, какой подходит вам больше всего для вашего дизайна.

Теперь мы готовы разобраться с еще одним советом в этой статье. Двигаемя дальше.

## Комбинирование модульного масштабирования и вертикального ритма

В [предыдущей статье](ссссылка) я показал вам, как можно задавать свойство `line-height` для `$typi` мапы и для остальных мап, относящихся к конкретным элементам:

```scss
$typi: (
  null: (16px, 1.5) // значение высоты строки 1.5
);

$h1-map: (
  null: (ms(3), 1.2) // значение высоты строки 1.2
);
```

Эти значения `line-height` (и 1.2 и 1.5) называются безразмерными, потому что у них нет единиц измерения (таких как, например, `px`, `em` или `rem`).

Использование безразмерных единиц - это рекомендуемая практика, потому что дочерние элементы, будут наследовать это свойство и вычислять собственную высоту строки относительно их размера шрифта, вместо того, чтобы получать уже готовую величину и использовать ее вне зависимости от собственного размера шрифта.

Безразмерные значения высоты строки это конечно круто, но они предстовляют некоторую сложность в работе с вертикальным ритмом, особенно, если вы определяете размер шрифта, основываясь на модульно масштабировании.

Давайте я покажу на примере, что я имею в виду.

Перед тем как продолжить, я предполагаю, что вы знаете, что такое вертикальный ритм. Если это не так, то прочтите об этом [здесь](ссссылка).

Скажем, у нас есть `font-size` со значением `16px` и `line-height` со значением `24px`. А размер шрифта заголовка `3.157em` (50.5px).

Когда мы руководствуемся вертикальным ритмом на странице, мы предполагаем, что `line-height` текстовых элементов кратно значению базовой линии. Так что высота строки заголовка должна принимать какое-то из этих значений: 48px, 60px или 72px (2, 2.5 или 3 значения базовой линии. Посмотрите [здесь](ссссылка), почему мы используем эту цепочку кратных чисел.)

Вопрос заключается в том, чему эквивалентны 48px, 60px и 72px в безразмерных `line-height`? Тут не обойтись без сложной арифметики.

К примеру, если у вас line-heiht прнимает значение 60px, то ее эквивалентная безразмерная величина будет 1.19 (60/50.5). Получается нам нужно сначала посчитать `font-size` согласно модульному масштабированию, а уже потом считать безразмерную высоту строки...

Достаточно много работы.

Есть вариант по-проще, если вы не против использовать значения line-height с указанной размерностью.

Как вы помните, у Typi есть функция `vr()`, которая помогает вам вычислить размер определенного количества значений базовой линии и вывести значение в `rem`. Мы знаем, что 48px это 2 значения базовой линии, 60px это 2.5 значения базовой линии, а 72px это 3 значения соответственно.

Так что если вы намерены упростить калькуляцию, то вы можете использовать функцию `vr()` прямо в ваших шрифтовых мапах для вычисления значения высоты строки:

```scss
$h1: (
  null: (ms(4), vr(2.5))
);

h1 {
  @include typi($h1);
}
```

CSS будет такой:

```scss
h1 {
  font-size: 3.157rem;
  line-height: 3.75rem; /* 2.5 базовых линий */
}
```

Тадааа! Прелесть использования `rem`.

Много людей, к примеру Miriam Suzanne, создатель [Susy](http://susy.oddbird.net/) используют этот подход уже долгое время.

К тому же, я читаю, что использование `line-height` в `rem` здесь вполне оправадано, так как это маловероятно, что вы собираетесь использовать, допустим, текст внутри `<h1>`, наследующий необработанное значение высоты строки родителя. А уж если такое случилось, то, возможно, настало время пересмотреть структуру вашей разметки HTML.

Заметка: Не используйте этот подход в мапе `$typi`, если вы хотите сохранить безразмерность высторы строки.

## Заключение

На этом пока все! В этой статье вы научились:

* Создавать медиа-запросы в `em` с Typi
* Использовать модульное масштабирование с Typi
* Комбинировать модульное масштабирование и вертикальный ритм

Существуют еще некоторые интересные вещи, которые вы можете проделать с Typi. Об этом я расскажу в последующих постах :)

А пока попробуйте в действии эти новые мощные подходы! Расскажите, что вы об этом думаете, в комментариях.
