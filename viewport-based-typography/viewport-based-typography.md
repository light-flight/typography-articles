# Как использовать единицы окна просмотра (vw) в типографике

Я говорил об использовании [rem и em](ссссылка) единиц в [отзывчивчивой типографике](ссссылка) и о создании модульных компонентов в двух предыдущих постах. В обеих статьях комментарии на счет единиц окна просмотра (вьюпорта) неизбежно привели меня к этой теме.

Я некоторе время сопротивлялся и избегал этих единиц, предполагая, какой болью могут обернуться расчеты, связанные с их использованием. На прошлой неделе я преодолел сопротивление и сделал первые попытки в понимании работы этих единиц в контексте отзывчивой типографики.

Прежде чем мы пойдем дальше, давайте сначала разберем, что именно представляют из себя единицы окна просмотра.

## Что такое единицы измерения окна просмотра

На сегодняшний момент существует 4 разных типа единиц вьюпорта в CSS:

* `vw` - проценты от ширины вьюпорта
* `vh` - проценты от высоты вьюпорта
* `vmin` - меньшее из `vw` и `vh`
* `vmax` - большее из `vw` и `vh`

**Вьюопорт - окно просмотра браузера.** `1vw` это один процент ширины вьюпорта. Соответственно `100vw` - это вся ширина окна просмотра (вьюпорта).

Что самое приятное в этих единицах, **они автоматически пересчитываются при изменении размера вьюпорта**. Это происходит при загрузке, при ресайзе и даже при смене ориентации устройства.

Поскольку единицы вьюпорта автоматически перерасчитываются, нет ничего проще, чем создать с помощью них элемент, который всегда будет занимать четверть экрана:

```scss
.component {
  width: 50vw;
  height: 50vh;
  background: rgba(255, 0, 0, 0.25)
}
```

Вот как работают эти единицы. Теперь перейдем к сути этой статьи.

## Использование единиц вьюпорта в типографике

Есть только **одна весомая причина**, которая заставляет рассматреть использование этих единиц в типографике - **автоматический перерасчет при любом изменении размеров браузера клиента**. Это означает, что отпадает всякая необходимость использовать переобъявление размера шрифта с помощью медиа-запросов.

Приведем пример, чтобы поконкретней увидеть, как это будет работать.

Возьмем следующий код, где размер шрифта будет изменится от `16px` до `20px` после опорной точки в `800px`:

```scss
// Заметка: все стили пишу с использованием SCSS
html {
  font-size: 16px;

  @media (min-width: 800px) {
    font-size: 20px;
  }
}
```

Взглянув на код, сразу можно сказать, что `font-size` "перескочит" с 16 до 20 пикселей на ширине вьюпорта в 800px. Это привычный для нас подход.

Впоследствии вы возможно столкнетесь с такой ситуацией, что вам понадобится добавить еще один дополнительный медиа-запрос между двух других запросов, для того чтобы улучшить отзывчивость типографики:

```scss
html {
  font-size: 16px;

  @media (min-width: 600px) {
    font-size: 18px;
  }

  @media (min-width: 800px) {
    font-size: 20px;
  }
}
```

Мы можем пойти дальше и определить еще больше медиа-запросов, но обычно так не делают, ограничиваясь лишь тремя-четырьмя значениями опорных точек.

**Но как насчет возможности добиться подобного эффекта без определения множества медиа-запросов и множества размеров шрифтов?**

Вот, где в дело вступаю единицы размера вьюпорта. Вы можете добиться похожего эффекта, просто задав свойство `font-size` в единицах вьюпорта.

Примерный эквивалент кода выше будет выглядеть так:

```scss
html { font-size: 3vw; }
```

Просто удивительно, не правда ли?

Хотя вы можете видеть **недостаток в черезмерной чувствительности к изменению ширины экрана**.

Если задать размер шрифта `3vw`, как я сделал выше, то мы получим шрифт в 10px на ширине экрана 320px (мобильный вариант). Это слишком мало для удобного чтения. С другой стороны шрифт вырастет до 43px на девайсах с шириной экрана 1440px (ноутбук). Это слишком много.

**Теперь мы подошли к занимательной проблеме** - укрощение единиц окна просмотра.

К счастью есть один подход, решающий проблему малыми жертвами. **Мы можем установить минимальный размер шрифта, затем масштабировать шрифт с помощью умножения на малую величину единицы вьюпорта, используя функцию `calc()`.**

Вот как это будет выглядеть в коде:

```scss
html { font-size: calc(18px + 0.25vw) }`
```

Смотрится круто, да? Я впервые услышал об этой технике в статье [точный контроль над отзывчивой типографикой](http://madebymike.com.au/writing/precise-control-responsive-typography) (автор [Mike Riethmuller](http://madebymike.com.au/)).

К сожалению, **я обнаружил, что этот код не работает корректо во всех браузерах**. К примеру, текст не масштабируется при ресайзе в Safari на Mac (Mike также упоминает, что и на Windows тоже).

**Фикс оказался чрезвычайно простым.** Для корректной работы и в Safari, требуется комбинировать проценты и `vw`:

```scss
html { font-size: calc(112.5% + 0.5vw) }
```

Тадааа!

Отлииииично! Но можем ли мы избавиться от `em`, `rem` и медиа-запросов в нашем коде? На этом моменте, пожалуй можно обойтись и без них!

Следующим испытанием будет попытка задать значения размера шрифта для всех остальных типографических элементов в единицах размера окна просмотра.

## Настройка остальных типографических элементов в единицах вьюпорта

В первую очередь я попытался создать заголовок первого уровня, который бы был в два раза больше основного текста документа. Оказалось, это не так просто :(

Я попробовал умножить на 2 мое значение размера шрифта `<html>` элемента и увидел, что результат получился больше, чем должен был быть:

```scss
html { font-size: calc(112.5% + 0.25vw) }
h1 { font-size: calc((112.5% + 0.25vw) * 2); }
```

**Так произошло потому что я использую значение, в котором есть вычисления с процентами.** Фактически я перерасчитываю `font-size` моего `<h1>` после наследования им вычисленного значения `font-size` от `html`.

Будет проще это визуализировать, если мы сделаем это на конкретных числах.

Скажем, сейчас размер вьюпорта равен 800px. По умолчанию размер шрифта эквивалентен 16px.

* вычислив 112.5% от `<html>`, получим размер шрифта в 18px (`112.5/100 * 16px`)
* 0.25vw в нашем случае равен 2px (`800px * 0.25 ÷ 100`)
* Вычисленнное значение размера шрифта `<html>` элемента это **20px** (`18px + 2px`)

Пока все идет нормально для вычислений относительно `<html>`. Хорошо.

Далле мы используем тот же метод для вычисления размера шрифта заголовка первого уровня. **Уделите особенное внимание значению 112.5%, когда будем считать размер `<h1>` в этот раз.**

* 112.5% для `<h1>` будет эквивалентен 22.5px (`112.5/100 * `**`20px`**)
* 0.25vw неизменно дадут значение в 2px в нашем случае (`800px * 0.25 ÷ 100`)
* Вычисленное значение размера заголовка будет **49px** (`((22.5px + 2px) * 2)`)

К сожалению, **нужное нам значение (в два раза больше размера основного текста тела документа) равно 40px**. Но его мы не получили:(

**Зная, что проблема возникает при наследовании заголовком `<h1>` размера шрифта элемента `<html>`, мы можем решить ее двумя следующими способами.**

Первый способ это изменить в формуле для заголовка величину процентов (`112.5%` на `100%`):

```scss
h1 { font-size: calc((100% + 0.25vw) * 2) }
```

Второй способ это убедиться, что никакого наследования между элементами не происходит.

```scss
h1 { font-size: calc((100% + 0.25vw) * 2) }
p { font-size: calc((100% + 0.25vw)) }
```

**Оба этих способа начинают напоминать костыли**, поэтому я продолжил поиски решения этой проблемы.

В итоге, **самым лаконичным способом оказался возврат к использованию относительных единиц [rem и em](ссссылка)**. Почему мы должны отбрасывать старые добрые способы только ради "блестящих" новых? :)

```scss
html { font-size: calc(112.5% + 0.25vw) }
h1 { font-size: 2em; }
```

С тех пор как мы занялись масштабированием размера шрифта в единицах окна просмотра, у вас наверно уже возник вопрос: **"А что если мы попробуем использовать подобный подход для работы с модульным масштабированием и вертикальным ритмом?"**

Это как раз то, о чем мы поговорим в следующем разделе.

## Вериткальный ритм и модульное масштабирование с использованием единиц размера вьюпорта

Ответ относительно прост.

Мы пришли к тому, что использовали единицы ширины вьюпорта только для определения размера шрифта корневого элемента `<html>`. Для всего остального вы по прежнему использовали `rem` и `em`!

**Это означает, что мы как и раньше можем использовать `em` и `rem` для создания вертикального ритма и модульного маштабирования в той же манере, как мы делали это в статье ["все, что я знаю об отзывчивой типографике"](ссссылка).

Ничего не поменялось! :)

О, еще один момент, прежде чем закончить эту статью.

Существует еще одна сложность, которую мне пришлось преодолеть. У меня возник вопрос: **"Как я могу рассчитать значение в vw таким образом, чтоб получить размер шрифта в 20px на экране шириной 800px?"**

Слишком специфичный и большой вопрос, давайте сократим его до одного слова - **точность**. Другими словами, как мне быть более точным с размерами шрифта, которые я собираюсь использовать?

## Точность

Оказывается Mike уже решил этот вопрос. Я собираюсь объяснить как работает его формула.

Скажем нам нужен...

* размер шрифта равный **18px** при ширине вьюпорта **600px**

* размер шрифта равный **22px** при ширине вьюпорта **1000px**

**В-первых мы должны конвертировать меньший размер `font-size` в проценты.** Первая часть вычисления выглядит так: (`calc(18/16 * 100%)` или просто `calc(112.5%)`).

**Дальше вычисляем значение vw.** Эта часть арифметики чуть посложнее.

Нужно взять разницу в размерах шрифта (`22 - 18`) и подилить ее на разницу в ширинах вьюпорта (`1000 - 600`), затем умножить это на `100vw - меньшая-ширина-вьюпорта` (`100vw - 600px`).

**Когда мы объединим две этих части, то получится:

```scss
html {
  font-size: calc(112.5% + 4 * (100vw - 600px) / 400)
}
```

Впервые это может показаться достаточно сложным, но вы легко можете составить соответствующий Sass миксин.

[Indrek Paas](https://twitter.com/indrekpaas) уже конвертировал эту формулу в [простой Sass миксин](http://www.sassmeister.com/gist/7f22e44ace49b5124eec). Единственное изменение, которое я бы сделал, это заменил бы пиксели на проценты.

## Супер точность

А как будет выглядеть применение единиц вьюпорта, если вы хотите изменить коэффициент масштабирования после определенной опорной точки?

Вот ответ:

```scss
html {
  font-size: 100%;

  // Увеличивается по 1px каждые 100px на экранах шириной от 600px до 1000px
  @media (min-width: 600px) {
    font-size: calc(112.5% + 4 * (100vw - 600px) / 400)
  }

  // Увеличивается по 0.5px каждые 100px на экранах шириной от 1000px до 2000px
  @media (min-width: 1000px) {
    font-size: calc(137.5% + 5 * (100vw - 1000px) / 1000)
  }
}
```

Но на практике, вы вряд ли будете менять коэффициент масштабирования. Это означает, что более жизненной реализацией будет нечто подобное:

```scss
html {
  font-size: 100%;

  // Увеличивается по 1px каждые 100px на экранах шириной от 600px и более
  @media (min-width: 600px) {
    font-size: calc(112.5% + 4 * (100vw - 600px) / 400)
  }

  // Размер шрифта устанавливается 22px на всех ширинах экрана больших 1000px
  @media (min-width: 1000px) {
    font-size: calc(137.5%)
  }
}
```

Уловили идею? Не стесняйтесь комбинировать единицы вьюпорта с медиа-запросами для получения нужного вам эффекта. А теперь, наверно, наиболее актуальный вопрос:

**Буду ли я использовать единицы вьюпорта в реальном проекте?**

Вполне возможно. Я еще не работал достаточное количество времени с этими единицами, чтобы делать какое-то заключение. Но вот вещи, которые мне понадобятся перед тем, как использовать этот подход на реальных проектах:

1. Создать Sass миксин для вычисления vw
2. Протестировать поддержку браузерами и возможные дополнительные баги

Это будет просто замечательно, если вы уведомите меня в комментариях, о найденных багах по этой теме!

**ОЧЕНЬ ВАЖНОЕ ОБНОВЛЕНИЕ:** Благодаря Paul, мы я узнал, что `calc` с процентами совршенно не работает в IE (11 и даже Edge). После моего личного теста, казалось все было в порядке, но ребята [здесь](https://www.sitepoint.com/community/t/font-size-calc-100-0-3vw-not-working-in-ie/218960/6) доказали мне обратное.

Так что если вы собираетесь использовать единицы вьюпорта, вы можете прописать обычную `calc()` функцию с **`em`** единицами, а затем еще одну функцию `-webkit-calc()` с процентами внутри:

```scss
html {
  font-size: calc(0.875em + 0.25 * (100vw - 80em) / 40);
  font-size: -webkit-calc(87.5% + 0.25 * (100vw - 8000%) / 40);
}
```

Взгляните, Indrek любезно предоставил нам [демо на Codepen](http://codepen.io/indrekpaas/pen/VarLaJ) насчет этого момента.

## Заключение

В целом в этой статье мы поговорили с вами об использовании единиц размера окна просмотра для определения размеров в типографике. **Эти единицы могут быть очень выгодными, так как перерасчитываются автоматически при изменении ширины окна браузера.**

В ходе подробного разбора, я определил, что наиболее удобно определять размер шрифта корневого элемента в единицах вьюпорта. А для всего остального использовать старые добрые `em` и `rem`, благодаря чему мы смогли без проблем использовать уже изученные практики с вертикальным ритмом и модульным масштабированием.

Что вы думаете об использовании единиц размера вьюпорта в типографике? Будет здорово, если вы поделитесь своими мыслями в комментариях!
